// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef DRIVETRAIN_H
#define DRIVETRAIN_H
#include "Commands/Subsystem.h"
#include "WPILib.h"
#include "CANTalon.h"
#include "../MotionController.h"
#include "PIDOutput.h"
#include "PIDController.h"
#include "AHRS.h"

//in header drive
#define max_adjust 4	//(6 is too large, anything below 2 is too small)
#define max_angle 45.0

/**
 *
 *
 * @author ExampleAuthor
 */
class DriveTrain: public Subsystem, public PIDOutput {
private:
	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<CANTalon> left1;
	std::shared_ptr<CANTalon> right2;
	std::shared_ptr<CANTalon> right1;
	std::shared_ptr<CANTalon> left2;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	bool HighSpeed;

	std::shared_ptr<MotionController> leftMC;
	std::shared_ptr<MotionController> rightMC;

	std::shared_ptr<PIDController> turnControl;

	bool motionControlled;

public:
	DriveTrain();
	void InitDefaultCommand();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	void TankDrive(float left, float right);
	void ArcadeDrive(float x, float y);	//arcade drive also works as a split drive
	void SetPosition(int left, int right);
	void DirectDrive(float left, float right);
	void HeadingDrive(float output);	//recalculates the outputs on the right and left side based on the angle
										//(so the robot can drive straight)
	void StopMotors();

	void Config();
	void SetVoltageMode();
	void SetPositionMode();

	void Rotate_by_PID(float angle);
	virtual void PIDWrite(double output);


	// Motion Control Methods.

	// Adds a preplanned profile for both left and right sides of the drivetrain.
	// Profiles are associated to index which allows the profiles to be added prior
	// to sending over the CAN bus to the talons.  The gainslot is the PID slot on the
	// Talons to be used for the inner loop Talon logic.
	void AddMotionProfile(int index, int gainslot, double leftProfilePoints[][3], int leftSize,
			                                       double rightProfilePoints[][3], int rightSize );

	// Sets the motion profile by its index.  Returns true if profiles were found.
	bool SetActiveMotionProfile(int index);

	// Starts the current motion profile. Initiates the CAN bus transfer to the talons.
	void StartMotionProfile();

	// Must be called by the command in its execute method.
	void MotionControl();

	// Forces a stop of the currently executing motion profile.  Basically calls reset.
	void StopMotionProfile();

	// Stops and resets the motion profiles in the talons.
	void ResetMotionProfile();

	// Returns an indication if the motion profile is in progress.
	bool MotionProfileInProgress();

	// Returns if the motion profile has completed.
	bool MotionProfileComplete();

	// Enables/Disables debug.
	void EnableMotionDebug(bool enable = true);


	float Limit(float num);

	void ToggleHighSpeed();
	bool GetHighSpeed();


};

#endif
